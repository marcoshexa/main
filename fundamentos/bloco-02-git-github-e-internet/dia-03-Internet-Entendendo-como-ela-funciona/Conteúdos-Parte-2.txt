O protocolo HTTP

Como vimos no v√≠deo acima, o funcionamento da Internet depende de regras, que s√£o os protocolos. √â atrav√©s desses protocolos que conseguimos acessar p√°ginas, fazer downloads, enviar emails. Dentre os protocolos, h√° dois que s√£o frequentemente utilizados: o protocolo TCP/IP e o protocolo HTTP.
O Protocolo TCP/IP, como vimos, √© a base de envio e recebimento de dados de toda a Internet. √â um conjunto de regras que permite a comunica√ß√£o entre todas as m√°quinas conectadas √† Internet.
Vamos nos aprofundar um pouco mais sobre o que √© o protocolo HTTP, quais seus principais verbos e o que significa ser RESTful?
Voc√™ j√° aprendeu que, no modelo Cliente-Servidor, a troca de mensagens acontece atrav√©s de requisi√ß√µes e respostas: o Cliente envia uma requisi√ß√£o ao Servidor, que ir√° lhe retornar uma resposta. Com o grande volume de dados envolvidos nessa opera√ß√£o, gerenciar essas mensagens n√£o √© uma tarefa f√°cil. Assim, Cliente e Servidor aderem a uma linguagem comum, com regras que alinham as expectativas de ambas as partes, de forma que eles sabem exatamente o que esperar. Essa linguagem √© o que chamamos de protocolo HTTP.
Cada requisi√ß√£o e resposta trocada entre Cliente e Servidor √© uma √∫nica transa√ß√£o HTTP. O HTTP √© uma linguagem de texto, o que significa que as mensagens trocadas s√£o quantificadas em bits. Cada mensagem √© dividida em duas partes: o header e o body.
√â importante ter em mente que o HTTP por si s√≥ n√£o consegue transmitir dados. Ele ainda depende do protocolo TCP/IP para pegar as requisi√ß√µes e respostas entre duas m√°quinas. O HTTP √© uma camada de abstra√ß√£o que padroniza a forma com que os hosts se comunicam.
Uma requisi√ß√£o ou resposta HTTP pura n√£o √© encriptada, sendo vulner√°vel a v√°rios tipos de ataques. Por outro lado, HTTPS √© uma forma mais segura de comunica√ß√£o que utiliza a encripta√ß√£o. Para adicionar mais essa camada de seguran√ßa, o HTTPS utiliza um segundo mecanismo de seguran√ßa: o SSL. N√£o se preocupe em entender os detalhes e as diferen√ßas entre cada protocolo. Por hora, √© interessante saber que eles existem. Websites grandes com milhares de usu√°rios, como o Google e o Facebook, utilizam o protocolo HTTPS para manter as nossas senhas, informa√ß√µes pessoais e at√© mesmo detalhes de cart√£o de cr√©dito em seguran√ßa na rede.
Vamos fazer uma segunda busca para entender sobre o protocolo HTTP. No seu navegador, busque por https://github.com/. Clique com o bot√£o direito, selecione "Inspecionar" e procure por Network na barra superior. Navegue para o reposit√≥rio da Trybe na sua barra de navega√ß√£o com a janela de inspecionar aberta: https://github.com/betrybe/. Selecione o primeiro nome e a aba Headers. Voc√™ ver√° uma tela como a que √© mostrada abaixo:

Header.
HTTP Headers
Como vimos, o protocolo HTTP √© composto por Header e Body. O Header cont√©m metadata (dados sobre dados) que incluem o tipo de requisi√ß√£o (GET, POST, PUT, DELETE), o caminho URL, o endere√ßo IP dentre outros. Para a p√°gina que estamos usando como exemplo, na sess√£o Response Headers os mais importantes s√£o:
Content-Type: text/plain Especifica como os dados s√£o representados. Nesse exemplo, temos o texto sendo enviado como resposta no formato HTML.
Server: GitHub.com Servidor Web para onde as requisi√ß√µes est√£o sendo feitas.
Status: 200 OK Forma padr√£o para o servidor comunicar ao cliente sobre o resultado da requisi√ß√£o. O c√≥digo 200 significa que o servidor encontrou o recurso e est√° enviando o resultado da requisi√ß√£o.
Host: api.github.com Host da aplica√ß√£o
cookie: _octo=GH1.1.358825508.1593780201; _ga=GA1.2.60245099.1593780202; logged_in=yes; dotcom_user=isabellavjs; tz=America%2FSao_Paulo
Novamente, voc√™ n√£o precisa saber todos os pares de nome-valor. Saber onde encontr√°-los no seu navegador √© o suficiente para voc√™ come√ßar a explor√°-los conforme a sua necessidade.
HTTP Body
O servidor armazena ent√£o os dados (metadados) mais importantes para estabelecer uma comunica√ß√£o com o cliente. O Body refere-se ao corpo da mensagem que est√° sendo transmitida. Voc√™ pode acess√°-lo clicando em Response na barra superior. Para a requisi√ß√£o que fizemos, acessar a p√°gina https://github.com/, o body cont√©m o HTML para a p√°gina que estamos querendo acessar. Para praticar, experimente navegar nos outros arquivos que foram retornados para o navegador ap√≥s a requisi√ß√£o! Voc√™ pode acess√°-los no menu dispon√≠vel na barra lateral esquerda.

Body.
M√©todos HTTP
Os m√©todos HTTP s√£o os verbos que dizem ao servidor o que fazer com os dados no URL. Como vimos, o endere√ßo URL identifica recursos espec√≠ficos. Quando o cliente utiliza o endere√ßo URL combinado a um verbo HTTP, o servidor saber√° qual ser√° a a√ß√£o necess√°ria para cada recurso. Os exemplos mais comuns s√£o:
GET
O m√©todo GET √© o mais comum, e √© utilizado para ler informa√ß√µes encaminhadas pelo servidor para uma URL espec√≠fica. As requisi√ß√µes GET s√£o apenas para leitura, o que significa que os dados nunca poder√£o ser modificados no servidor. O servidor ir√° apenas retornar os dados, sem modific√°-los. Assim, esse tipo de requisi√ß√£o √© considerada uma opera√ß√£o segura, pois o efeito retornado ser√° sempre o mesmo, independentemente do n√∫mero de requisi√ß√µes feitas. Assim sendo, dizemos que requisi√ß√µes GET s√£o idempotentes, o que significa que o efeito da requisi√ß√£o no servidor ser√° sempre o mesmo - fazer milh√µes de requisi√ß√µes GET para o mesmo URL tem o mesmo efeito que uma √∫nica requisi√ß√£o. O m√©todo GET apenas retorna dados.
Requisi√ß√µes GET s√£o respondidas com status 200 (OK) se o recurso que estamos querendo acessar for encontrado com sucesso, ou 404 (NOT FOUND) se a p√°gina n√£o for encontrada.

404 - Page not found.
POST
O m√©todo POST √© utilizado para criar um novo recurso, como um formul√°rio para login. Voc√™ usar√° o m√©todo POST para criar um recurso subordinado (ex: novo usu√°rio) para a aplica√ß√£o pai (ex: http://exemplo.com/usuario). Ao contr√°rio do m√©todo GET, o m√©todo POST n√£o √© nem seguro e nem idempotente. Fazer duas ou mais requisi√ß√µes POSTS resultar√° em novos recursos criados (mesmo que id√™nticos). Requisi√ß√µes POST s√£o retornadas com o status code 201 (CREATED) e um novo caminho no header com o Link do recurso criado.
PUT
O m√©todo PUT √© utilizado para atualizar o recurso identificado pelo URL. Esse m√©todo tamb√©m pode ser utilizado para criar um novo recurso. Requisi√ß√µes PUT n√£o s√£o consideradas opera√ß√µes seguras, pois o estado da aplica√ß√£o √© modificado no servidor. No entanto, o m√©todo PUT √© idempotente porque m√∫ltiplas requisi√ß√µes PUT para atualizar um recurso t√™m o mesmo efeito que uma √∫nica requisi√ß√£o.
A resposta a requisi√ß√£o √© o status code 200 (OK) se o recurso foi atualizado com sucesso, ou 404 (NOT FOUND) se ele n√£o for encontrado.
DELETE
DELETE √© utilizado para deletar um recurso identificado pelo URL. As requisi√ß√µes DELETE s√£o idempotentes, pois quando deletamos um recurso ele ser√° deletado. Voc√™ pode fazer milhares de requisi√ß√µes com o m√©todo DELETE que no fim o resultado ser√° o mesmo: um recurso deletado.
A resposta requisi√ß√£o √© o status code 200 (OK) se o recurso for deletado com sucesso, ou 404 (NOT FOUND) se o recurso que ser√° deletado n√£o existir.
REST
Voc√™ pode j√° ter ouvido falar do termo RESTful para descrever uma aplica√ß√£o. REST √© a sigla para Representational State Transfer. √â um estilo de arquitetura utilizado no design de aplica√ß√µes Web. O estado da aplica√ß√£o s√£o os dados necess√°rios para que o servidor possa atender a uma determinada requisi√ß√£o. As regras do REST nos guiam a desenvolver sistemas mais perform√°ticos, escal√°veis, simples, de f√°cil manuten√ß√£o e modifica√ß√£o, port√°til e confi√°vel. Dentre elas, podemos destacar:
Interface uniforme: define a interface entre cliente e servidor de forma a desacoplar a arquitetura da aplica√ß√£o. Os verbos que vimos acima descrevem a grande maioria das regras para interface uniforme. Dentre as defini√ß√µes previstas pelo REST, as mais importantes s√£o:
Recursos, como dados de um banco de dados, devem ser identificados na requisi√ß√£o e o cliente ter√° acesso apenas a representa√ß√£o do recurso (ex: JSON, HTML)
O cliente deve ter informa√ß√µes suficientes para manipular recursos no servidor utilizando representa√ß√µes
As mensagens trocadas entre cliente e servidor devem ser auto-descritivas
Stateless: Essa regra define que todos os dados do estado da aplica√ß√£o que precisam ser manipulados em uma requisi√ß√£o devem estar contidos na pr√≥pria requisi√ß√£o (URL, HTTP body, HTTP header) e o servidor deve encaminhar para o cliente todos os dados referentes ao estado na resposta (HTTP headers, status code, HTTP response body).
O protocolo HTTP √© uma pe√ßa chave na comunica√ß√£o entre cliente-servidor. Para construir aplica√ß√µes RESTFul √© necess√°rio compreender o b√°sico de HTTP. Assim, voc√™ ser√° capaz de criar p√°ginas perform√°ticas e escal√°veis que far√£o a diferen√ßa na vida de muitos usu√°rios!
Agora responda ao quiz, lembrando que ele serve para fixa√ß√£o dos conte√∫dos e n√£o tem car√°ter avaliativo, n√£o se preocupe! üòâ
Quiz - Protocolo HTTP & REST
Curl
Por fim, voc√™ vai aprender sobre o comando curl, abrevia√ß√£o para Client URL. Ele √© um comando dispon√≠vel na maioria dos sistemas baseados em Unix que serve para verificar conectividade, al√©m transferir dados via terminal.
Antes de avan√ßarmos no conte√∫do, √© necess√°rio verificar a vers√£o instalada do curl. Para isto, abra o terminal e utilize o comando abaixo.
Para Linux:
Copiar
curl --version
Para MacOS:
Copiar
curl -V
Se o curl estiver devidamente instalado, seu terminal exibir√° uma mensagem similar a:
Para Linux:
Copiar
curl 7.68.0 (x86_64-pc-linux-gnu) libcurl/7.68.0 OpenSSL/1.1.1f zlib/1.2.11 brotli/1.0.7 libidn2/2.2.0 libpsl/0.21.0 (+libidn2/2.2.0) libssh/0.9.3/openssl/zlib nghttp2/1.40.0 librtmp/2.3
Release-Date: 2020-01-08
Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp
Features: AsynchDNS brotli GSS-API HTTP2 HTTPS-proxy IDN IPv6 Kerberos Largefile libz NTLM NTLM_WB PSL SPNEGO SSL TLS-SRP UnixSockets
Para MacOS:
Copiar
curl 7.68.0 (x86_64-apple-darwin16.0) libcurl/7.68.0 SecureTransport zlib/1.2.8
Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp Features: AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz UnixSockets
Caso voc√™ ainda n√£o possua o comando curl instalado, seguiremos um passo a passo para realizarmos a instala√ß√£o tanto em Linux quanto em MacOS.
Linux
Este comando ir√° atualizar a lista de pacotes e programas que podem ser instalados, em seguida, ir√° baixar e instalar os pacotes de atualiza√ß√£o dos programas que est√£o instalados.
Copiar
sudo apt update && sudo apt upgrade
Agora utilizaremos o comando que far√° a instala√ß√£o do curl.
Copiar
sudo apt install curl
Por fim cheque novamente a vers√£o do curl para garatirmos que tudo foi instalado corretamente.
Copiar
curl --version
MacOS
Por padr√£o o comando curl j√° vem instalado. No entanto, pode ser que algum problema tenha acontecido e o comando n√£o esteja instalado. Caso esta seja sua situa√ß√£o, siga os comandos abaixo. üòâ
No terminal, execute o comando abaixo.
Caso seja solicidata uma senha, utilize a sua senha de usu√°rio. Ela n√£o aparecer√° na tela, por√©m, o sistema ir√° identific√°-la. Ao terminar aperte a tecla enter.
Copiar
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" < /dev/null 2> /dev/null
Fa√ßa a instala√ß√£o do curl utilizando este comando.
Copiar
brew install curl
Por fim cheque novamente a vers√£o do curl para garatirmos que tudo foi instalado corretamente.
Copiar
curl -V
Assim como voc√™ far√° com toda nova tecnologia que aprender em programa√ß√£o, o primeiro passo na maioria das vezes √© dar uma olhada na documenta√ß√£o! A documenta√ß√£o cont√©m muitas informa√ß√µes √∫teis que podem nos poupar tempo de pesquisa se a analisarmos.
Com a etapa de instala√ß√£o concluida e a documenta√ß√£o em m√£os, vamos conhecer um pouco mais sobre o comando rodando exemplos pr√°ticos no terminal!
Sintaxe b√°sica do curl.
Copiar
curl [OPTIONS] [URL]
Options aqui podemos especificar diversas op√ß√µes que nos permitem acessar informa√ß√µes e definir comportamentos/configura√ß√µes, como por exemplo:
-u ou --user: Permite especificar nome de usu√°rio e senha para autentica√ß√£o no servidor.
-T ou --upload-file: Permite transferir arquivos locais para uma URL remota.
-s ou --silent: Coloca o curl em modo silencioso. Este comando far√° com que mensagens de erro e status de progress√£o n√£o gerem nenhum tipo de notifica√ß√£o.
Caso voc√™ queira conhecer mais op√ß√µes, √© poss√≠vel acessar o manual completo do curl atrav√©s do comando curl --manual.
URL √© o endere√ßo WEB ao qual vamos nos referir para fazer nossas requisi√ß√µes via comando curl.
Agora faremos nossa primeira requisi√ß√£o para um site.
Copiar
curl testdomain.com
Note que a resposta que voc√™ receber√° no terminal ser√° um c√≥digo HTML que como vimos anteriormente, permite configurar a estrutura f√≠sica da p√°gina web.
Al√©m disto, observe tamb√©m que as tags <html>, <head>, <title>, <body> e <h1> est√£o presentes na resposta. A tag <h1> foi vista anteriormente no conte√∫do e representa o t√≠tulo principal. As demais tags n√≥s veremos com mais detalhes no pr√≥ximo bloco de conte√∫do. üöÄ
Nesta pr√≥xima etapa, utilizaremos uma option do comando curl, conhecida como --head. Ela nos permitir√° ter acesso a todo cabe√ßalho da p√°gina. N√£o se preocupe em entender todos os detalhes, v√°rios pontos que est√£o presentes nesta resposta ser√£o vistos por voc√™ com profundidade ao longo do curso!
Copiar
curl --head https://www.betrybe.com/
Nesta requisi√ß√£o ao site da trybe, recebemos algumas informa√ß√µes como por exemplo:
Status da requisi√ß√£o: est√° representado pelo n√∫mero 200, e nos informa que nossa requisi√ß√£o foi feita com sucesso.
Server: Servidor Web para onde as requisi√ß√µes est√£o sendo feitas.
Content-type: Especifica como os dados s√£o representados. Neste caso, text/html.
Por fim, veremos como podemos fazer uma requisi√ß√£o de download para uma URL espec√≠fica, utilizando a option -O. A partir desta requisi√ß√£o voc√™ ter√° acesso ao arquivo localmente, no diret√≥rio em que o terminal est√° rodando.
Copiar
curl -O https://uploads-ssl.webflow.com/5dbd9ce75ad64f24b67f0932/5dbdd9165ad64f5e29811c52_BRAND3.png
Note que o arquivo em sua m√°quina ter√° o mesmo nome do arquivo remoto. √â comum que as nomenclaturas de arquivos remotos n√£o sejam descritivas. Para resolver este problema, podemos utilizar uma segunda option do comando curl que nos permitir√° nomear o arquivo da forma que desejarmos.
Copiar
curl -o trybe_logo.png https://uploads-ssl.webflow.com/5dbd9ce75ad64f24b67f0932/5dbdd9165ad64f5e29811c52_BRAND3.png
Observe que agora o download foi feito com o nome trybe_logo.png.
Interessante quanta informa√ß√£o conseguimos acessar atrav√©s de comandos simples no terminal n√£o √© mesmo? Existem diversas outras options que podem ser utilizadas via comando curl, por√©m, n√£o nos aprofundaremos neste conte√∫do por agora.
Se voc√™ quiser se aprofundar mais, alguns exerc√≠cios e um artigo sobre curl foram separados na na se√ß√£o de Recursos Adicionais. A leitura do artigo e realiza√ß√£o dos exerc√≠cios √© opcional, e √© mais uma forma de voc√™ colocar em pr√°tica todos os conceitos que viu at√© aqui, al√©m de refletir sobre eles enquanto cria as requisi√ß√µes usando o terminal. üíªüêÅ
